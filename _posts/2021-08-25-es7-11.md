---
git@gitee.com:sjdt/geekhall.cn.gitlayout: post
title:  "ES7-11新特性"
date:   2021-08-25 12:10:25 +0800
categories: ES7
---

# ES7-ES11新特性

## ES7
### Array.prototype.includes()
```javascript
const mingzhu = ['西游记', '红楼', '水浒','三国'];

console.log(mingzhu.includes('三国'));  // true
console.log(mingzhu.includes('金瓶梅'));  // false
```

### 指数操作符
```javascript
console.log(2**8);          // 256
```

## ES8
### async 和 await
async和await两种语法结合可以让异步代码像同步代码一样。

#### async函数
* async函数的返回值为promise对象。
* promise对象的结果由async函数执行的返回值决定

```javascript
async function getData(){
    // 返回结果是一个Promise对象
    return 'GeekHall';
}

const result = getData();
console.log(result); 
```
![](https://yinyang.space/img/20210825_es7_1.png)

```javascript
async function getData(){
    // 抛出错误，返回一个失败的Promise
    throw new Error('出错了');
}

const result = getData();
console.log(result); 
```

![](https://yinyang.space/img/20210825_es7_2.png)

使用Promise
```javascript
async function getData(){
    return new Promise((resolve, reject) => {
        resolve('成功的数据');
    });
}

const result = getData();

// 调用then方法
result.then(value => {
    console.log(value);
}, reason => {
    console.warn(reason);
});

```
![](https://yinyang.space/img/20210825_es7_3.png)


#### await表达式
* await必须写在async函数中
* await右侧的表达式一般为promise对象
* await返回的是promise成功的值
* await的promise失败了，就会抛出异常，需要通过try...catch捕获异常

```javascript

// 创建Promise对象
const p = new Promise((resolve, reject) => {
    resolve("成功的值！！");
});

// await 要放在async函数中
async function main(){
    let result = await p;
    console.log(result);
}

// 调用函数
main();
```

异常情况
```javascript
// 创建Promise对象
const p = new Promise((resolve, reject) => {
    reject("失败的值！！");
});

// await 要放在async函数中
async function main(){
    try{
        let result = await p;
        console.log(result);
    } catch (e){
        console.log(e);
    }
}

// 调用函数
main();
```


async和await的结合使用：

下面内容保存为sample.js
```javascript
const fs = require('fs');

function readFile1(){
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file1.md", (err, data) =>{
            // 如果失败
            if (err) reject(err);

            // 如果成功
            resolve(data);
        })
    })
}


function readFile2(){
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file2.md", (err, data) =>{
            // 如果失败
            if (err) reject(err);

            // 如果成功
            resolve(data);
        })
    })
}

function readFile3(){
    return new Promise((resolve, reject) => {
        fs.readFile("./resources/file3.md", (err, data) =>{
            // 如果失败
            if (err) reject(err);

            // 如果成功
            resolve(data);
        })
    })
}

// 声明一个async函数
async function main(){
    let file1 = await readFile1();
    let file2 = await readFile2();
    let file3 = await readFile3();

    console.log(file1.toString());
    console.log(file2.toString());
    console.log(file3.toString());
}

main();
```

然后执行：`node sample.js` ，即可读取三个文件的内容。



### 使用async和await发送ajax请求
```javascript

// 发送Ajax请求，返回的结果是Promise对象。
function sendAjax(url){
    return new Promise((resolve,reject) => {
        
        // 创建对象
        const x = new XMLHttpRequest();

        // 初始化
        x.open('GET', url);

        // 发送
        x.send();

        // 事件绑定
        x.onreadystatechange = function(){
            if (x.readyState === 4){
                if (x.status >= 200 && x.status < 300) {
                    // 成功
                    resolve(x.response);
                } else {
                    // 失败
                    reject(x.status);
                }
            }
        }
    });
}

// promise then 方法测试
// sendAjax("https://api.apiopen.top/getJoke").then(value => {
//     console.log(value);
// }, reason => {
//     console.warn(reason);
// });


// async 与 await 方法测试 以后使用axios
// 推荐的做法是axios发请求，await接结果。
async function main (){
    // 发送ajax请求
    let result = await sendAjax("https://api.apiopen.top/getJoke");
    console.log(result);
}
main();
```


### 对象展开

Rest参数与spread扩展运算符在ES6中已经引入，不过ES6中只针对数组
在ES9中为对象提供了像数组一样的rest参数和扩展运算符。

```javascript
function connect({host, port, username, password}){
    console.log(host);
    console.log(port);
    console.log(username);
    console.log(password);
}

connect({
    host: "127.0.0.1",
    port: 3306,
    username: 'root',
    password: '123456'
})
```

上面的操作在ES9中可以写成下面这种方式：
```javascript
function connect({host, port, ...user}){
    console.log(host);
    console.log(port);
    console.log(user);
}

connect({
    host: "127.0.0.1",
    port: 3306,
    username: 'root',
    password: '123456',
    type: 'master'
})
```

### 对象的展开和合并
```javascript
// 对象的展开和合并：
const skillOne = {
    q: '天音破'
}

const skillTwo = {
    w: '金钟罩'
}

const skillThree = {
    e: '天雷破'
}

const skillFour = {
    r: '神龙摆尾'
}

const mengseng = {...skillOne, ...skillTwo, ...skillThree, ...skillFour};
console.log(mengseng);
```


### 正则表达式扩展


```javascript
let str = '<a href="http://www.geekhall.cn">极客堂</a>';

const reg = /<a href="(.*)>(.*)<\/a>/;

const result = reg.exec(str);
console.log(result);
console.log(result[1]); // http://www.geekhall.cn
console.log(result[2]); // 极客堂
```

使用分组：
```javascript
const reg1 = /<a href="(?<url>.*)">(?<text>.*)<\/a>/;

const result1 = reg1.exec(str);
console.log(result1);
console.log(result1.groups.url);    // http://www.geekhall.cn
console.log(result1.groups.text);   // 极客堂
```

![](https://yinyang.space/img/20210826_es_1.png)


### 正则扩展 - 反向断言
```javascript
// 正向断言
let str2 = 'JS1314极客堂520哈哈哈哈哈';
const reg2 = /\d+(?=哈)/;
const result2 = reg2.exec(str2);
console.log(result2);
console.log(result2[0]); // 520

// 不加断言
const reg3 = /\d+/;
const result3 = reg3.exec(str2);
console.log(result3);
console.log(result3[0]); // 1314


// 反向断言
const reg4 = /(?<=堂)\d+/;
const result4 = reg4.exec(str2);
console.log(result4);
console.log(result4[0]); // 520
```


### ES10 Object.fromEntries
ES8中 Object.entries的反操作，可以将二维数组转化为对象。

```javascript
const arr = Object.fromEntries([
    ['name', '极客堂'],
    ['xueke', ' Java, Python, Php']
]);

// Map
const m = new Map();
m.set('name', 'GeekHall');
const result5 = Object.fromEntries(m);

console.log(result5);
```


### ES10 trimStart，trimEnd
用来清除字符串左侧空白或者右侧空白


### ES10 flat与flatMap
flat可以将多维数组转化为低维数组
```javascript
const arr = [1,2,3,4,[5,6]];
// flat的参数为深度
console.log(arr.flat(2));   // [1,2,3,4,5,6]
```


flatMap
Map结果维度降低
```javascript
const arr = [1,2,3,4]
const result = arr.map(item => [item*10]);  // 返回一个二维数组     [[10],[20],[30],[40]]
const resultFlat = arr.flatMap(item => [item*10]);  // 返回一个一维数组 [10,20,30,40]
console.log(result);
```



